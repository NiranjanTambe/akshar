% \iffalse
%<*driver>
\documentclass{l3doc}
\usepackage[margin=1cm,left=7cm,bottom=1.5cm]{geometry}
\usepackage{fontspec}
\usepackage{unicode-math}
\setmainfont[Scale=0.9,Script=Devanagari]{Shobhika}
\setsansfont{Linux Biolinum}
\setmathfont{Linux Libertine}
\setmonofont[Scale=0.85]{Hack NF}
\renewcommand\meta[1]{$\langle${\itshape\rmfamily#1}$\rangle$}
\usepackage{akshar}
\usepackage[listings]{tcolorbox}
\newtcblisting{codeexample}[1][]{size=minimal,
  sidebyside gap=1cm,lefthand width=6.5cm,lower separated=false,
  fontupper=\raggedleft,colback=white,colframe=white,
  verbatim ignore percent,grow to left by=7cm,text side listing,
  listing options={basicstyle=\small,keywordstyle=\small,columns=fullflexible,
  numbers=left,numberstyle=\sffamily\tiny\color{gray},stepnumber=1,numbersep=5pt},#1}
\pgfkeys{/tcb/.cd,code only/.code={\pgfkeysalso{listing only,grow to left by=-5mm}}}
\def\PackageName{\jobname}
\def\PackageVersion{0.1}
\def\PackageDate{2020/05/17}
\parindent=0pt\relax
\IndexMin=100pt\relax
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
\DocInput{\PackageName.dtx}
\end{document}
%</driver>
% \fi
%
%
%
% \title{The \pkg{\PackageName} package}
% \author{Vu Van Dung}
% \date{Version \PackageVersion\qquad---\qquad\PackageDate}
%
% \maketitle
%
% \tableofcontents
% \parskip=1ex
%
% \begin{documentation}
% \section{Introduction}
% When dealing with processing strings in the Devanagari script, normal \LaTeX\ 
% commands usually find some difficulties in distinguishing ``normal'' 
% characters, like क, and ``special'' characters, for example  ् or ी. Let's 
% consider this example code:
% \begin{codeexample}[]
%\ExplSyntaxOn
%\tl_set:Nn \l_tmpa_tl { की }
%\tl_count:N \l_tmpa_tl \c_space_token tokens.
%\ExplSyntaxOff
% \end{codeexample}
% The output is 2, but the number of characters in it is only one! The reason 
% is quite simple: the compiler treats ी as a normal character, which it isn't.
%
% To tackle that, this package provides \pkg{expl3} functions to ``convert'' a 
% given string, written in the Devanagari script, to a sequence of token lists. 
% each of these token lists is a ``true'' Devanagari character. You can now do 
% anything you want with this sequence; and this package does provide some 
% front-end macros for some simple actions on the input string.
%
% \section{User guide}
% \end{documentation}
% 
% \StopEventually{\PrintIndex}
% 
% \begin{implementation}
% \section{Implementation}
%    \begin{macrocode}
%<@@=akshar>
%<*package>
%    \end{macrocode}
% Declare the package. By loading \pkg{fontspec}, \pkg{xparse}, and in turn, 
% \pkg{expl3}, are also loaded.
%    \begin{macrocode}
\RequirePackage{fontspec}
\ProvidesExplPackage {akshar} {2020/05/17} {0.1}
  {Support for syllables in the Devanagari script (JV)}
%    \end{macrocode}
% \begin{variable}{\c_@@_joining_tl, \c_@@_diacritics_tl}
% These variables store the special characters we need to take into account:
% \begin{itemize}
%   \item \cs{c_@@_joining_tl} is the ``connecting'' character  ्.
%   \item \cs{c_@@_diacritics_tl} is a list of all diacritics: ािीुूेैोौंःॢृॅँ (they are 
%    ा,  ि,  ी,  ु,  ू,  े,  ै,  ो,  ौ,  ं,  ः,  ॢ,  ृ,  ॅ,  ँ without the 
%   commas).
% \end{itemize}
%    \begin{macrocode}
\tl_const:Nn \c_@@_joining_tl { ्}
\tl_const:Nn \c_@@_diacritics_tl {ािीुूेैोौंःॢृॅँ}
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_@@_prev_joining_bool}
% When we get to a normal character, we need to know whether it is joined, i.e. 
% whether the previous character is the joining character. This boolean variable 
% takes care of that.
%    \begin{macrocode}
\bool_new:N \l_@@_prev_joining_bool
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_@@_char_seq}
% This local sequence stores the output of the converter.
%    \begin{macrocode}
\seq_new:N \l_@@_char_seq
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_@@_tmp_tl}
% A temporary token list, used during the modification of the sequence.
%    \begin{macrocode}
\tl_new:N \l_@@_tmp_tl
%    \end{macrocode}
% \end{variable}
% \begin{macro}[TF]{\tl_if_in:No}
% When we get to a character which is not the joining one, we need to know if 
% it is a diacritic. The current character is stored in a variable, so an 
% expanded variant is needed. We only need it to expand only \textbf{o}nce.
%    \begin{macrocode}
\prg_generate_conditional_variant:Nnn \tl_if_in:Nn { No } { TF }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\akshar_convert:n}
% This converts |#1| to a sequence of \emph{true} Devanagari characters. The 
% sequence is \cs{l_@@_char_seq}.
%    \begin{macrocode}
\cs_new:Npn \akshar_convert:n #1
  {
%    \end{macrocode}
% Clear anything stored in advance. We don't want different calls of the 
% function to conflict with each other.
%    \begin{macrocode}
    \seq_clear:N \l_@@_char_seq
    \bool_set_false:N \l_@@_prev_joining_bool
%    \end{macrocode}
% Loop through every token of the input.
%    \begin{macrocode}
    \tl_map_variable:NNn {#1} \l_@@_map_tl
      {
        \tl_if_in:NoTF \c_@@_diacritics_tl {\l_@@_map_tl}
          {
%    \end{macrocode}
% It is a diacritic. We append the current diacritic to the last item of the 
% sequence instead of pushing the diacritic to a new sequence item.
%    \begin{macrocode}
            \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
            \seq_put_right:Nx \l_@@_char_seq 
              { \l_@@_tmp_tl \l_@@_map_tl }
          }
          {
            \tl_if_eq:NNTF \l_@@_map_tl \c_@@_joining_tl
              {
%    \end{macrocode}
% In this case, the character is the joining character,  ्. What we do is 
% similar to the above case, but \cs{l_@@_prev_joining_bool} is set to true so 
% that the next character is also appended to this item.
%    \begin{macrocode}
                \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
                \seq_put_right:Nx \l_@@_char_seq 
                  { \l_@@_tmp_tl \l_@@_map_tl }
                \bool_set_true:N \l_@@_prev_joining_bool
              }
              {
%    \end{macrocode}
% Now the character is normal. We see if we can push to a new item or not. It 
% depends on the boolean variable.
%    \begin{macrocode}
                \bool_if:NTF \l_@@_prev_joining_bool
                  {
                    \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
                    \seq_put_right:Nx \l_@@_char_seq 
                      { \l_@@_tmp_tl \l_@@_map_tl }
                    \bool_set_false:N \l_@@_prev_joining_bool
                  }
                  {
                    \seq_put_right:Nx \l_@@_char_seq { \l_@@_map_tl }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{implementation}
%
% \Finale