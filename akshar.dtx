% \iffalse
%<*driver>
\documentclass{l3doc}
\usepackage[margin=1cm,left=7cm,bottom=1.5cm]{geometry}
\usepackage[libertine]{newtxmath}
\usepackage{fontspec}
\setmainfont[Scale=0.9,Script=Devanagari]{Shobhika}
\setsansfont{Linux Biolinum}
\setmonofont[Scale=0.85]{Hack NF}
\renewcommand\meta[1]{$\langle${\itshape\rmfamily#1}$\rangle$}
\usepackage{akshar}
\usepackage[listings]{tcolorbox}
\newtcblisting{codeexample}[1][]{size=minimal,
  sidebyside gap=1cm,lefthand width=6.5cm,lower separated=false,
  fontupper=\raggedleft,colback=white,colframe=white,
  verbatim ignore percent,grow to left by=7cm,text side listing,
  listing options={basicstyle=\small,keywordstyle=\small,columns=fullflexible,
  numbers=left,numberstyle=\sffamily\tiny\color{gray},stepnumber=1,numbersep=5pt},#1}
\pgfkeys{/tcb/.cd,code only/.code={\pgfkeysalso{listing only,grow to left by=-5mm}}}
\def\PackageName{\jobname}
\def\PackageVersion{0.1}
\def\PackageDate{2020/05/17}
\parindent=0pt\relax
\IndexMin=100pt\relax
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
\DocInput{\PackageName.dtx}
\end{document}
%</driver>
% \fi
%
%
%
% \title{The \pkg{\PackageName} package}
% \author{Vu Van Dung}
% \date{Version \PackageVersion\ --- \PackageDate}
%
% \maketitle
%
% \begin{abstract}
%   This package provides tools to deal with special characters in a Devanagari 
%   string.
% \end{abstract}
%
% \tableofcontents
% \parskip=1ex
%
% \begin{documentation}
% \section{Introduction}
% When dealing with processing strings in the Devanagari script, normal \LaTeX\ 
% commands usually find some difficulties in distinguishing ``normal'' 
% characters, like क, and ``special'' characters, for example  ् or ी. Let's 
% consider this example code:
% \begin{codeexample}[]
%\ExplSyntaxOn
%\tl_set:Nn \l_tmpa_tl { की }
%\tl_count:N \l_tmpa_tl \c_space_token tokens.
%\ExplSyntaxOff
% \end{codeexample}
% The output is 2, but the number of characters in it is only one! The reason 
% is quite simple: the compiler treats ी as a normal character, which it isn't.
%
% To tackle that, this package provides \pkg{expl3} functions to ``convert'' a 
% given string, written in the Devanagari script, to a sequence of token lists. 
% each of these token lists is a ``true'' Devanagari character. You can now do 
% anything you want with this sequence; and this package does provide some 
% front-end macros for some simple actions on the input string.
%
% \section{User manual}
% \subsection{\LaTeXe\ macros}\label{latex2e-macros}
% \begin{function}{\aksharStrLen}
%   \begin{syntax}
%     \cs{aksharStrLen} \marg{token list}
%   \end{syntax}
% Return the number of Devanagari characters in the \meta{token list}.
% \end{function}
% \begin{codeexample}[]
%There are \aksharStrLen{ घघाघिघीघुघूघेघै } characters in घघाघिघीघुघूघेघै.\par
%\ExplSyntaxOn
%\pkg{expl3}~returns~\tl_count:n { घघाघिघीघुघूघेघै },~which~is~wrong.
%\ExplSyntaxOff
% \end{codeexample}
% \begin{function}{\aksharStrChar}
%   \begin{syntax}
%     \cs{aksharStrChar} \marg{token list} \marg{n}
%   \end{syntax}
% Return the $n$-th character of the token list.
% \end{function}
% \begin{codeexample}[]
%4th character of घघाघिघीघुघूघेघै is \aksharStrChar{ घघाघिघीघुघूघेघै}{4}.\par
%\ExplSyntaxOn
%It~is~not~\tl_item:nn { घघाघिघीघुघूघेघै } {4}.
%\ExplSyntaxOff
% \end{codeexample}
% \subsection{\pkg{expl3} functions}
% This section assumes that you have a basic knowledge in \LaTeX3 programming.
% All macros in \ref{latex2e-macros} directly depend on the following function,
% so it is much more powerful than all features we have described above.
% \begin{function}{
%    \akshar_convert:Nn, \akshar_convert:cn, 
%    \akshar_convert:Nx, \akshar_convert:cx}
%   \begin{syntax}
%     \cs{akshar_convert:Nn} \meta{seq var} \marg{token list}
%   \end{syntax}
%   This function converts \meta{token list} to a sequence of characters, that 
%   sequence is stored in \meta{seq var}. The assignment to \meta{seq var} is 
%   local to the current \TeX\ group.
% \end{function}
% \begin{codeexample}[]
%\ExplSyntaxOn
%\akshar_convert:Nn \l_tmpa_seq { घघाघिघीघुघूघेघै }
%\seq_use:Nnnn \l_tmpa_seq { ~and~ } { ,~ } { ,~and~ }
%\ExplSyntaxOff
% \end{codeexample}
% \end{documentation}
% 
% \StopEventually{\PrintIndex}
% 
% \begin{implementation}
% \section{Implementation}
%    \begin{macrocode}
%<@@=akshar>
%<*package>
%    \end{macrocode}
% Declare the package. By loading \pkg{fontspec}, \pkg{xparse}, and in turn, 
% \pkg{expl3}, are also loaded.
%    \begin{macrocode}
\RequirePackage{fontspec}
\ProvidesExplPackage {akshar} {2020/05/17} {0.1}
  {Support for syllables in the Devanagari script (JV)}
%    \end{macrocode}
% \begin{variable}{\c_@@_joining_tl, \c_@@_diacritics_tl}
% These variables store the special characters we need to take into account:
% \begin{itemize}
%   \item \cs{c_@@_joining_tl} is the ``connecting'' character  ्.
%   \item \cs{c_@@_diacritics_tl} is a list of all diacritics: ािीुूेैोौंःॢृॅँ (they are 
%    ा,  ि,  ी,  ु,  ू,  े,  ै,  ो,  ौ,  ं,  ः,  ॢ,  ृ,  ॅ,  ँ without the 
%   commas).
% \end{itemize}
%    \begin{macrocode}
\tl_const:Nn \c_@@_joining_tl { ्}
\tl_const:Nn \c_@@_diacritics_tl {ािीुूेैोौंःॢृॅँ}
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_@@_prev_joining_bool}
% When we get to a normal character, we need to know whether it is joined, i.e. 
% whether the previous character is the joining character. This boolean variable 
% takes care of that.
%    \begin{macrocode}
\bool_new:N \l_@@_prev_joining_bool
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_@@_char_seq}
% This local sequence stores the output of the converter.
%    \begin{macrocode}
\seq_new:N \l_@@_char_seq
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_@@_tmp_tl, \l_@@_tmp_seq}
% Some temporary variables.
%    \begin{macrocode}
\tl_new:N \l_@@_tmp_tl
\seq_new:N \l_@@_tmp_seq
%    \end{macrocode}
% \end{variable}
% \begin{macro}[TF]{\tl_if_in:No}
% When we get to a character which is not the joining one, we need to know if 
% it is a diacritic. The current character is stored in a variable, so an 
% expanded variant is needed. We only need it to expand only \textbf{o}nce.
%    \begin{macrocode}
\prg_generate_conditional_variant:Nnn \tl_if_in:Nn { No } { TF }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\akshar_convert:Nn, \akshar_convert:cn,
%               \akshar_convert:Nx, \akshar_convert:cx}
% This converts |#2| to a sequence of \emph{true} Devanagari characters. The 
% sequence is set to |#1|, which should be a sequence variable. The assignment 
% is local.
%    \begin{macrocode}
\cs_new:Npn \akshar_convert:Nn #1 #2
  {
%    \end{macrocode}
% Clear anything stored in advance. We don't want different calls of the 
% function to conflict with each other.
%    \begin{macrocode}
    \seq_clear:N \l_@@_char_seq
    \bool_set_false:N \l_@@_prev_joining_bool
%    \end{macrocode}
% Loop through every token of the input.
%    \begin{macrocode}
    \tl_map_variable:NNn {#2} \l_@@_map_tl
      {
        \tl_if_in:NoTF \c_@@_diacritics_tl {\l_@@_map_tl}
          {
%    \end{macrocode}
% It is a diacritic. We append the current diacritic to the last item of the 
% sequence instead of pushing the diacritic to a new sequence item.
%    \begin{macrocode}
            \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
            \seq_put_right:Nx \l_@@_char_seq 
              { \l_@@_tmp_tl \l_@@_map_tl }
          }
          {
            \tl_if_eq:NNTF \l_@@_map_tl \c_@@_joining_tl
              {
%    \end{macrocode}
% In this case, the character is the joining character,  ्. What we do is 
% similar to the above case, but \cs{l_@@_prev_joining_bool} is set to true so 
% that the next character is also appended to this item.
%    \begin{macrocode}
                \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
                \seq_put_right:Nx \l_@@_char_seq 
                  { \l_@@_tmp_tl \l_@@_map_tl }
                \bool_set_true:N \l_@@_prev_joining_bool
              }
              {
%    \end{macrocode}
% Now the character is normal. We see if we can push to a new item or not. It 
% depends on the boolean variable.
%    \begin{macrocode}
                \bool_if:NTF \l_@@_prev_joining_bool
                  {
                    \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
                    \seq_put_right:Nx \l_@@_char_seq 
                      { \l_@@_tmp_tl \l_@@_map_tl }
                    \bool_set_false:N \l_@@_prev_joining_bool
                  }
                  {
                    \seq_put_right:Nx \l_@@_char_seq { \l_@@_map_tl }
                  }
              }
          }
      }
%    \end{macrocode}
% Set |#1| to \cs{l_@@_char_seq}. The assignment is local, and I have not found 
% a way to automatically pick \cs{seq_set_eq} or \cs{seq_gset_eq} based on the 
% name of the sequence variable.
%    \begin{macrocode}
    \seq_set_eq:NN #1 \l_@@_char_seq
  }
%    \end{macrocode}
% Generate variants that might be helpful for some.
%    \begin{macrocode}
\cs_generate_variant:Nn \akshar_convert:Nn { cn, Nx, cx }
%    \end{macrocode}
% \end{macro}
% Time for some front-end macros that can be used directly in the \LaTeXe\ 
% context.
% \begin{macro}{\aksharStrLen}
% Expands to the length of the string.
%    \begin{macrocode}
\NewExpandableDocumentCommand \aksharStrLen {m}
  {
    \akshar_convert:Nn \l_@@_tmp_seq {#1}
    \seq_count:N \l_@@_tmp_seq
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\aksharStrChar}
% Returns the $n$-th character of the string.
%    \begin{macrocode}
\NewExpandableDocumentCommand \aksharStrChar {mm}
  {
    \akshar_convert:Nn \l_@@_tmp_seq {#1}
    \seq_item:Nn \l_@@_tmp_seq {#2}
  }
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{implementation}
%
% \Finale