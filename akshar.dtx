% \iffalse
%<*driver>
\documentclass{l3doc}
\usepackage[margin=1cm,left=7cm,bottom=1.5cm]{geometry}
\usepackage{fontspec}
\usepackage{unicode-math}
\setmainfont[Scale=0.9,Script=Devanagari]{Shobhika}
\setsansfont{Linux Biolinum}
\setmathfont{Linux Libertine}
\setmonofont[Scale=0.85]{Hack NF}
\renewcommand\meta[1]{$\langle${\itshape\rmfamily#1}$\rangle$}
\usepackage{akshar}
\usepackage[listings]{tcolorbox}
\newtcblisting{codeexample}[1][]{size=minimal,
  sidebyside gap=1cm,lefthand width=6.5cm,lower separated=false,
  fontupper=\raggedleft,colback=white,colframe=white,
  verbatim ignore percent,grow to left by=7cm,text side listing,
  listing options={basicstyle=\small,keywordstyle=\small,columns=fullflexible,
  numbers=left,numberstyle=\sffamily\tiny\color{gray},stepnumber=1,numbersep=5pt},#1}
\pgfkeys{/tcb/.cd,code only/.code={\pgfkeysalso{listing only,grow to left by=-5mm}}}
\def\PackageName{\jobname}
\def\PackageVersion{0.1}
\def\PackageDate{2020/05/17}
\parindent=0pt\relax
\IndexMin=100pt\relax
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
\DocInput{\PackageName.dtx}
\end{document}
%</driver>
% \fi
%
%
%
% \title{The \pkg{\PackageName} package}
% \author{Vu Van Dung}
% \date{Version \PackageVersion\qquad---\qquad\PackageDate}
%
% \maketitle
%
% \tableofcontents
% \parskip=1ex
%
% \begin{documentation}
% \section{Introduction}
% When dealing with processing strings in the Devanagari script, normal \LaTeX\ 
% commands usually find some difficulties in distinguishing ``normal'' 
% characters, like क, and ``special'' characters, for example  ् or ी. Let's 
% consider this example code:
% \begin{codeexample}[]
%\ExplSyntaxOn
%\tl_set:Nn \l_tmpa_tl { की }
%\tl_count:N \l_tmpa_tl \c_space_token tokens.
%\ExplSyntaxOff
% \end{codeexample}
% The output is 2, but the number of characters in it is only one! The reason 
% is quite simple: the compiler treats ी as a normal character, which it isn't.
%
% To tackle that, this package provides \pkg{expl3} functions to ``convert'' a 
% given string, written in the Devanagari script, to a sequence of token lists. 
% each of these token lists is a ``true'' Devanagari character. You can now do 
% anything you want with this sequence; and this package does provide some 
% front-end macros for some simple actions on the input string.
%
% \section{User guide}
%
% \mystrchar{aक्षbकौcक्ष्यd}{1}\par
% \mystrchar{aक्षbकौcक्ष्यd}{2}\par
% \mystrchar{aक्षbकौcक्ष्यd}{3}\par
% \mystrchar{aक्षbकौcक्ष्यd}{4}\par
% \mystrchar{aक्षbकौcक्ष्यd}{5}\par
% \mystrchar{aक्षbकौcक्ष्यd}{6}\par
% \mystrchar{aक्षbकौcक्ष्यd}{7}\par
% \end{documentation}
% 
% \StopEventually{\PrintIndex}
% 
% \begin{implementation}
% \section{Implementation}
%    \begin{macrocode}
%<@@=akshar>
%<*package>
%    \end{macrocode}
% Declare the package.
%    \begin{macrocode}
\RequirePackage{fontspec}
\ProvidesExplPackage {akshar} {2020/05/17} {0.1}
  {Support for syllables in the Devanagari script (JV)}
%    \end{macrocode}
%    \begin{macrocode}
\tl_const:Nn \c_@@_joining_tl { ्}
\tl_const:Nn \c_@@_diacritics_tl {ािीुूेैोौंःॢृॅँ}
\tl_new:N \l_@@_input_tl
\tl_new:N \l_@@_tmp_tl
\bool_new:N \l_@@_prev_joining_bool
\seq_new:N \l_@@_char_seq
\prg_generate_conditional_variant:Nnn \tl_if_in:Nn { No } { TF }
\cs_new:Npn \@@_str_getchar:nn #1 #2
  {
    \seq_clear:N \l_@@_char_seq
    \bool_set_false:N \l_@@_prev_joining_bool
    \tl_set:Nn \l_@@_input_tl {#1}
    \tl_map_variable:NNn \l_@@_input_tl \l_@@_map_tl
      {
        \tl_if_in:NoTF \c_@@_diacritics_tl {\l_@@_map_tl}
          {
            % It is a diacritic.
            \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
            \seq_put_right:Nx \l_@@_char_seq { \l_@@_tmp_tl \l_@@_map_tl }
          }
          {
            \tl_if_eq:NNTF \l_@@_map_tl \c_@@_joining_tl
              {
                % It is the joining character
                \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
                \seq_put_right:Nx \l_@@_char_seq 
                  { \l_@@_tmp_tl \l_@@_map_tl }
                \bool_set_true:N \l_@@_prev_joining_bool
              }
              {
                % It is a normal character
                \bool_if:NTF \l_@@_prev_joining_bool
                  {
                    % but previously there is a joining character
                    \seq_pop_right:NN \l_@@_char_seq \l_@@_tmp_tl
                    \seq_put_right:Nx \l_@@_char_seq 
                      { \l_@@_tmp_tl \l_@@_map_tl }
                    \bool_set_false:N \l_@@_prev_joining_bool
                  }
                  {
                    % Previously: nothing special.
                    \seq_put_right:Nx \l_@@_char_seq { \l_@@_map_tl }
                  }
              }
          }
        % Plus two just to guard against breaking too soon
        \int_compare:nNnT {\seq_count:N \l_@@_char_seq} > {#2 + 2}
          {
            \tl_map_break:
          }
      }
    \seq_item:Nn \l_@@_char_seq {#2}
  }
\NewDocumentCommand \mystrchar {mm}
  {
    \@@_str_getchar:nn {#1} {#2}
  }
%</package>
%    \end{macrocode}
% \end{implementation}
%
% \Finale